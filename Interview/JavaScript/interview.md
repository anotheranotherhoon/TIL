## 1. 클로져에 대해서 설명하세요.
클로저란 외부 함수의 변수에 접근할 수 있는 내부 함수입니다.
자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정합니다다. 이를 렉시컬 스코프라고하는데 함수는 자신이 호출되는 환경과는 상관없이 자신이 정의된 환경, 즉, 상위 스코프를 자신의 내부 슬롯 [[Environment]]에 상위 스코프의 참조를 저장한다. 

외부 함수보다 중첩함수가 더 오래 유지되는 경우 중첩함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있는데 이러한 중첩 함수를 클로저라고 부릅니다.

## 2.  호이스팅과 Temporal Dead Zone이 어떻게 연관되어있는지 설명하세요.
자바스크립트 엔진은 소스코드를 ‘소스코드의 평가'와 ‘소스코드의 실행'과정으로 나누어 처리한다.

자바스크립트 엔진은 소스코드 실행에 앞서 소스코드의 평가과정을 거치는데 소스코드의 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문을 소스코드에서 찾아내서 먼저 실행한다.

그리고 소스코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 소스코드를 한줄씩 순차적으로 실행한다.

자바스크립트 엔진은 변수 선언이 소스코드의 어디에 있든 상관 없이 다른 코드 보다 먼저 실행한다.

변수 선언은 소스코드가 순차적으로 실행되는 시점인 런타임 이전에 실행되지만, 값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.

소스코드의 평가과정을 시작하기에 앞서 자바스크립트의 실행 컨텍스트는 먼저 전역 객체를 생성한다.

전역 실행 컨텍스트를 생성하여 실행컨텍스트 스택에 푸시하고

전역 렉시컬 환경을 생성하여 전역 실행 컨텍스트에 바인딩한다.

전역 렉시컬 환경을 구성하는 컴포넌트인 전역 환경 레코드는 객체 환경 레코드와 선언적 환경 레코드로 구성되어 있다.

객체 환경 레코드는 기존의 전역 객체가 관리하던 var키워드로 선언한 변수와 함수 선언문으로 정의한 전역 함수를 관리한다.

선언적 환경 레코드는 let, const 키워드로 선언한 전역 변수를 관리한다.

객체 환경 레코드는 BindingObject라고 부르는 객체와 연결된다. (BindingObject는 전역 객체 생성단계에서 생성된 전역 객체입니다.)

전역 코드 평가 과정에서 var키워드로 선언한 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 환경 레코드와 객체 환경 레코드에 연결된 BindingObject를 통해 전역 객체의 프로퍼티와 메서드가 됩니다.

BindingObject를 통해 전역 객체에 변수 식별자를 키로 등록한 다음 암묵적으로 undefined를 바인딩한다.

이러한 이유로 var 키워드로 선언한 변수는 코드 실항 단계에서 변수 선언문 이전에도 참조할 수 있다 단, 변수 선언문 이전에 참조한 변수의 값은 언제나 undefined이다.

선언적 환경 레코드는 let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않고, 개념적인 블록내에 존재하게 되는데 여기서 개념적 블록이 바로 전역 환경 레코드의 선언적 환경 레코드입니다.

const로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행되는데 초기화 단계. 즉, 런타임에 변수 선언문에 도달하기 전까지 TDZ존에 빠지게 된다.

const로 선언한 변수도 변수 호이스팅이 발생한다. 단 const 키워드로 선언한 변수는 변수 선언문에 도달하기 전까지 TDZ존에 빠지기 때문에 참조할 수 없다.

## 3. callback, promise, async/await 의 특징과 차이점에 대해서 설명하세요.
자바스크립트는 싱글 스레드를 사용하는 언어입니다. 따라서 자바스크립트는 한번에 한 개의 일만 순차적으로 처리할 수 있습니다.

* Promise
  * Promise 란 기본적으로 callback이 하는 일과 같다. 
  * Promise는 작업이 끝난 후 실행할 함수를 제공하는 것이 아니라 Promise 자체 메서드인.then()을 호출하게 된다.

Promise는 .then()과 같은 메소드를 연속적으로 사용이 가능한 이점을 가지고 있다. 
따라서 callback을 사용했을때와는 다르게 코드를 작성하고 이해하기 쉬워졌다. 
Promise에서는 작업이 실패했을 경우 자동으로 .catch()메서드가 호출되게 된다. 
따라서 callback과 같이 함수 호출 중간에 if-else를 사용하는 것이 아닌.catch()로 해결할 수 있는 장점이 있다. 

## 4. event.preventDefault() 의 역할이 무엇인지 설명하세요.

## 5. 이벤트 버블링이란 무엇이며 막을 수 있는 방법은 무엇인가요?