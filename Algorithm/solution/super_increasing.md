## 문제
>수를 요소로 갖는 배열을 입력받아 각 요소들이 그 이전의 요소들의 합보다 큰지 여부를 리턴해야 한다.

## 입력
* 입력 인자 1: arr
    * 수를 요소로 갖는 배열
    * arr[i]는 정수

* 출력
    * boolean 타입을 리턴해야 한다.
    * arr[i]는 arr[0]부터 arr[i-1]까지의 합보다 커야 한다.

## 풀이

## 첫 번째 풀이

```
function superIncreasing(arr) {
  let sum = arr[0]
  for(let i = 1; i<arr.length; i++){
    if(sum<arr[i]){
      sum+=arr[i]
    }
    else{
      return false
    }
  }
  return true
}

```
* 이전 요소들의 값들의 합을 담아둘 sum 변수를 생성하였다. 그리고 처음부터 arr의 첫번째 인자 값을 할당했다.

* 그 이전의 요소들의 합보다 큰지 여부만 할당하면 되므로 1번째 인덱스 부터 반복문을 돌렸다.

* 조건문을 사용하여 만약 배열의 i번째 인덱스의 값이 그 이전 요소들의 합 보다 클 경우 sum에 arr의 i번째 인덱스의 값을 누적한다.

* 만약 배열의 i번째 인덱스의 값이 그 이전 요소들의 합보다 작을 경우 바로 false를 리턴한다.

* 따라서 배열을 끝까지 탐색하지 않고도 정답을 알아 낼수 도 있다.
---
## 두 번째 풀이
```
function superIncreasing(arr) {
  let answer = true
  arr.reduce((acc, current) => {
    if(acc>=current){
       answer = false // return answer = false라고 바꾸더라도 배열의 끝까지 순회한다.
    }
    return acc + current
  })
  return answer
}
```
> 이전 풀이에서 sum에 값이 누적되는것에 영감을 받아 reduce 메서드를 사용한 풀이를 해보았다.

* arr = [1, 3, 6, 13, 54]
    * 초기값을 정하지 않았으므로 배열의 첫 번째(0번째 인덱스 1) 요소가 초기값이 되고. 두 번째값(1번째 인덱스 3) 부터 current변수에 할당된다. 
    * 만약 초기값을 정했다면 배열의 첫 번째(0번째 인덱스 1)부터 current변수에 할당된다.

|호출 횟수|acc|current|currentIndex|반환값|
|---|---|---|---|---|
|1번째 호출|1|3|1|4|
|2번째 호출|4|6|2|10|
|3번째 호출|10|13|3|23|
|3번째 호출|23|54|3|77|

* 조건문을 통해 누적값이 현재 값보다 크거나 같을 경우 (acc>=current)  true로 초기화해뒀던 answer변수를 false로 재할당한다.

* 하지만 reduce문을 포함한 고차함수에서는 break, continue 문을 사용할 수 없다. 
    * 배열 고차함수(forEach, map, fliter 등)에서 break 와 continue의 사용이 불가하다. 해당 고차함수들에서는 이들을 문법적으로 지원하지 않기 때문이다.
    * 해당 고차함수를 쓰면서 반복을 중간에 끝내고 싶으면, 조건에 따라 예외를 주는 try, catch 구문을 사용하는 방법이 있다.


* 따라서 좋든 싫든 배열을 끝까지 탐색해야한다.

* 그러므로 고차 함수를 이용하였다 하여서 코드의 성능을 보장하지는 않는다.
---
## 마무리

* 프로그래머스에서 내가 많은 줄에 걸쳐 겨우 풀어낸 문제를 다른 분들은 고차 함수를 사용하여 컴팩트하게 풀어내는 것에 동경심을 느꼈다.

* map은 파이썬으로 문제를 풀 때 자주 접해 사용법이 익숙했고 forEach나 filter의 경우 직관적으로 사용법을 파악할 수 있었으나 reduce의 경우 최근에서야 그 사용법을 익히게 되었다.

* 오랜만에 reduce 사용법을 상기하고 능동적으로 내 필요에 의해 reduce를 사용했다는 것을 기념하고자 풀이법을 작성해 보았다.