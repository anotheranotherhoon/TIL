# 배열
>2022년 05월 10일
- 배열은 순서가 있는 값

- 값은 요소 (element)

- 프로퍼티와 메서드
```
let myNumber = [73, 98, 86, 61];
myNumber.length; // 4 프로퍼티 (온점을 이용해서 변수가 가지고 있는 속성(프로퍼티)에 접근)
myNumber.push(96); // 온점을 이용해서 관련된 명령(method라고 부른다.)도 실행할 수 있다. 
명령을 실행할 때는, 함수를 실행하듯 괄호를 열고 닫는 형태로 실행한다.
push는 함수이다. 
```

- 배열 리터럴은 객체리터럴과 달리 프로퍼티명이 없고 각 요소의 값만이 존재한다. 

- 객체는 프로퍼티 값에 접근하기 위해 대괄호 표기법 또는 마침표 표기법을 사용하며 프로퍼티명을 키로 사용한다. 

- 배열은 요소에 접근하기 위해 대괄호 표기법만을 사용하며 대괄호 내에 접근하고자 하는 요소의 인덱스를 넣어준다.

- splice(삭제를 시작할 인덱스, 삭제할 요소 수, 제거한 위치에 삽입할 요소들의 목록)
배열은 객체이기 때문에 배열의 요소를 삭제하기 위해 delete 연산자를 사용할 수 있다. 
이때 length에는 변함이 없다. 해당 요소를 완전히 삭제하여야 length도 반영되게 하기 위해서는 .splice()메서드를 사용한다.

```
const numberArr = ['zero', 'one', 'two', 'three'];

//요소 값만 삭제된다.
delete numberArr[2] = //(4) ['zero', 'one', empty, 'three'];

//splice는 요소 값만이 아니라 요소를 완전히 삭제한다.
numberArr.splice(2,1); // (3) ['zero', 'one', 'three'];

const arr = [1, 2, 3, 4];
//원본 배열의 인덱스 1부터 2개의 요소를 제거하고 그 자리에 새로운 요소 20, 30을 삽입한다.
const result = arr.splice(1, 2, 20, 30);

const arr1 = [1, 2, 3, 4];
//원본 배열의 인덱스 1부터 0개의 요소를 제거하고 그 자리에 새로운 요소 100을 삽입한다.
const result = arr.splice(1, 0, 100);
console.log(arr1) //[1, 100, 2, 3, 4]

```

- Array.isArray()
Array.isArray() 메서드는 인수가 배열이면 true, 배열이 아니면 false를 반환한다.

- Array.indexOf()
indexOf 메서드는 원본 배열에서 인수로 전달된 요소를 검색하여 인덱스를 반환한다.
> 1) 원본 배열에 인수로 전달한 요소와 중복되는 요소가 여러 개 있따면 첫 번째로 검색된 요소의 인덱스를 반환한다.<br>
2)원본배열에 인수로 전달한 요소가 존재하지 않으면 -1을 반환한다.

- includes()

- push()
push 메서드는 인수로 전달받은 모든 값을 원본 배열의 마지막 요소로 추가하고 **변경된 length 프로퍼티 값을 반환한다.** push메서드는 원본 배열을 직접 변경한다.
```
const arr = [1, 2];
//ES6 스프레드 문법
const newArr = [...arr, 3];
console.log(newArr); // [1, 2, 3]
```

- pop()
pop 메서드는 원본 배열에서 마지막 요소를 제거하고 제거한 요소를 반환한다. 
원본 배열이 빈 배열이면 undefined를 반환한다. 
pop 메서드는 원본 배열을 직접 변경한다.

- shift()
shift 메서드는 원본 배열에서 첫 번째 요소를 제거하고 제거한 요소를 반환한다. 원본 배열이 빈 배열이면 undefined를 반환한다. shift 메서드는 원본 배열을 직접 변경한다.

- unshift()
unshift 메서드는 원본 배열을 직접 변경하는 부수 효과가 있다. 따라서 unshift 메서드보다는 ES6의 스프레드 문법을 사용하는 편이 좋다. 
스프레드 문법을 사용하면 함수 호출 없이 표현식으로 선두에 요소를 추가할 수 있으며 부수효과도 없다.
```
const arr = [1, 2]
const newArr = [3, ...arr];
console.log(newArr); //[3, 1, 2]
```

- concat()
concat 메서드는 인수로 전달된 값들(배열 또는 원시값)을 원본 배열의 마지막 요소로 추가한 새로운 배열을 반환한다. 인수로 전달한 값이 배열인 경우 배열을 해체하여 새로운 배열의 요소로 추가한다. **원본 배열은 변경되지 않는다.**
```
const arr1 = [1, 2];
const arr2 = [3, 4];
let result = arr1.concat(arr2);
console.log(result); // [1, 2, 3, 4]
result = arr1.concat(3);
console.log(result); // [1, 2, 3]
result = arr1.concat(arr2, 5);
//배열 arr2 와 숫자를 원본 배열arr1의 마지막 요소로 추가한 새로운 배열을 반환한다.
console.log(result); //[1, 2, 3, 4, 5]
//원본 배열은 변경되지 않는다.
console.log(arr1);//[1, 2]
```

- slice(start, end)
slice 메서드는 인수로 전달된 범위의 요소들을 복사하여 배열로 반환한다. 원본 배열은 변경되지 않는다.
slice는 두 개의 매개변수를 갖는다.
> start : 복사를 시작할 인덱스다. 음수인 경우 배열의 끝에서의 인덱스를 나타낸다.
end : 복사를 종료할 인덱스다. 이 인덱스에 해당하는 요소는 복사되지 않는다. 생략시 기본 값은 length프로퍼티 값이다.

```
const arr = [1, 2, 3]
//arr[0]부터 arr[1] 이전(arr[1] 미포함)까지 복사하여 반환한다.
arr.slice(0, 1); // [1]
//원본은 변경되지 않는다.
console.log(arr); // [1,2,3]
```
slice 메서드의 인수를 모두 생략하면 원본 배열의 복사본을 생성하여 반환한다.
```
const arr = [1, 2, 3]

const copy = arr.slice();
console.log(copy); // [1, 2, 3]
```










