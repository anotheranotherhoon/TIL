> 그림으로 쉽게 배우는 운영체제 - 감자님 강의 참조

RR(Round Robin)
운영체제를 연구하는 사람들이 생각을 했습니다.

FIFO 알고리즘은 일괄처리 시스템에 적절해서 시분할 시스템에서는 쓰기가 힘들고 SJF 알고리즘은 프로세스의 종료시간을 예측하기 힘들다.

가장 단순한 FIFO 알고리즘에서 단점을 해결 해보기로 했다. 
FIFO 알고리즘의 단점은 먼저 들어온 프로세스가 전부 끝나야 다음 프로세스가 실행되는 것이다. 
이 문제를 해결하기 위해서 한 프로세스에게 일정 시간만큼 CPU를 할당하고 할당시간이 지나면 강제로 다른 프로세스에게 일정시간만큼 CPU를 할당한다. 

강제로 CPU를 뺏긴 프로세스는 큐의 가장 뒷부분으로 밀려난다. 이 알고리즘을 RR(Round Robin) 이라고 부른다.

프로세스에게 할당하는 일정 시간은 "타임 슬라이스" 또는 "타임 퀀텀"이라고 부른다.
RR알고리즘의 성능을 살펴보자.
타임 슬라이스가 10초인 시스템이라고 가정하고 평균 대기시간을 계산해보자.

P1(25s)P2(4s)P3(10s)
이 프로세스들은 동시에 큐에 들어왔고 실행 순서는 P1, P2, P3라고 가정하자.
P1은 큐에 들어오자마자 실행되기 때문에 대기시간이 0초이다.
P1은 타임 슬라이스 10초 만큼 실행하다가 시간을 초과했기 때문에 P2에게 CPU를 뺏기고 P1의 남은 작업은 큐의 가장 뒤로 이동한다.
P2는 P1이 실행하는 10초를 기다렸기 때문에 대기시간이 10초이다. P2는 Burst Time이 4초 이기 때문에 4초후 P3에게 양보하고 작업을 마친다.
P3는 P1과 P2의 실행이 완료될 때까지 14초를 기다렸다. 
P3는 10초 동안 작업을 하고 마친다.
다시 남은 작업P1은 P2와 P3의 작업일 14초 기다렸다.
따라서 38초를 프로세스의 갯수인 3으로 나누면 평균 대기 시간이 12.67초로 나온다.
FIFO 알고리즘은 18초가 나온다.
이 상황에서는 RR알고리즘이 더 빠르다.

다른 상황에서 RR알고리즘과 FIFO알고리즘의 평균대기시간이 비슷하다면 RR알고리즘이 더 비효율적인 방식이다.

RR알고리즘은 컨텍스트 스위칭이 있기 때문에 컨텍스트 스위칭 시간이 더 추가되기 때문이다. 

RR 알고리즘의 성능은 타임 슬라이스의 값에 따라 크게 달라진다. 두 가지 상황으로 알아보겠다.

먼저 타임슬라이스가 큰 경우
이론적으로 타임 슬라이스가 무한대라고 가정하면 먼저 들어온 프로세스의 작업이 종료될 때 까지 실행하니 FIFO알고리즘이 되버린다.

타임슬라이스가 작은 경우
타임 슬라이스를 1밀리초로 아주 작은 값으로 설정하면 웹브라우저와 뮤직플레이어가 동시에 동작하는 것 처럼 느껴질 것이다.
하지만 타임슬라이스가 작게 설정해버리면 컨텍스트 스위칭이 너무 자주 일어나게 되버리고 타임 슬라이스에서 실행되는 프로세스의 처리량 보다 컨텍스트 스위칭 처리량이 훨씬 커지면서 배보다 배꼽이 커지는 상황이 발생한다. 
이러한 상황을 "오버헤드가 너무 크다"라고 말한다.

최적의 타임 슬라이스를 결정하는 방법은 사용자가 느끼기에 여러 프로세스가 버벅거리지 않고 동시에 실행되는 것처럼 느껴지면서 오버헤드가 너무 크지 않는 값을 찾아야 하는 것이다. 

실제로 Windows는 타임 슬라이스가 20ms(밀리초)이고 Unix는 100ms 정도로 아주 짧다.
