> 그림으로 쉽게 배우는 운영체제 - 감자님 강의 참조
가변분할 방식을 이용하는 세그멘테이션 기법을 알아보자.

세그멘테이션에서 프로그램은 함수나 모듈등에서 세그먼트를 구성한다.

프로그램(사용자)입장에서 메모리를 살펴보면 메인 코드가 있는 세그먼트, 전역 데이터들이 있는 세그먼트 힙 영역이 있는 세그먼트, 스택 영역이 있는 세그먼트등이 있다. 각 세그먼트들은 서로 인접할 필요는 없다.

반면 프로세스 입장에서는 우리가 앞서 봤던 것처럼 코드 영역, 데이터 영역, 힙 영역, 스택 영역을 서로 인접한 것 처럼 바라본다.

사용자와 프로세스, CPU가 바라보는 주소는 논리주소라고 한다.

실제 물리주소로 변환은 중간에서 메모리 관리자 (MMU)가 해준다.

메모리 관리자는 어떻게 논리주소를 물리주소로 변환해줄까?

메모리 관리자는 세그멘테이션 테이블이라는 것을 가지고 있다.

세그멘테이션 테이블에는 Base Address와 Bound Address정보가 저장되고 이걸 이용해 물리 메모리 주소를 계산한다.

CPU에서 논리주소를 전달해주면 메모리관리자는 이 논리주소가 몇번 세그먼트인지 알아낸다.

그리고 메모리 관리자 내에 Segment Table Base Register를 이용해서 물리 메모리내에 있는 세그멘테이션 테이블을 찾고 세그먼트 번호를 인덱스로 Base Address와 Bound Address를 찾는다.

참고로 운영체제는 컨텍스트 스위칭을 할 때 마다 메모리 관리자 내에 Segment Table Base Register를 해당 프로세스의 것으로 값을 바꿔줘야한다.

컨텍스트 스위칭은 이런 작업까지 하기 때문에 굉장히 무거운 동작이다.

다시 설명으로 돌아가서 Bound Address는 세그먼트의 크기를 나타낸다.
메모리 관리자는 CPU에서 받은 논리주소와 이 Bound Address의 크기를 비교한다.

만약 논리주소가 Bound Address 보다 작다면 논리주소와 Base Address를 더해 물리주소를 구하고 논리 주소가 Bound Address보다 크다면 메모리를 침범했다고 생각하고 에러를 발생시킨다.

그럼 예시로 논리주소를 물리주소로 변환하는걸 2개만 살펴보자.

CPU에서 세그먼트 1번이 0x632번지로 접근한다고 가정해보자.
메모리 관리자는 CPU의 요청을 받고 세그먼트 1번인 것을 알아낸다.
그리고 메모리 관리자 내에 있는 Segment Table Base Register를 이용해서 세그멘테이션 테이블을 찾아낸다.

세그멘테이션 테이블을 찾은 다음 세그먼트 1번이 위치한 1번 인덱스를 참조한다.

논리주소 632와 Bound Address 1000을 비교하니 논리주소가 더 작다.

그럼 논리주소 632와 Base Address 5200을 더해 5832가 나온다.

최종적으로 논리주소 0x632번지는 물리주소 0x5832로 변환된다.

두 번째 예시는 세그먼트 3번이 0x750번지로 접근한다고 가정해보자.
메모리 관리자는 CPU의 요청을 받고 세그먼트 3번인 것을 알아낸다.

그리고 Segment Table Base Register를 통해 세그멘테이션 테이블을 찾아 3번 인덱스를 참조한다.

논리주소 750과 Base Address 500을 비교하니 논리주소가 더 크다.
그럼 메모리 관리자는 메모리를 침범했다고 판단하여 인터럽트를 발생시켜 프로세스를 종료시킨다.

세그멘테이션의 장점은 메모리를 가변적으로 분할 할 수 있고 데이터, 코드, 힙, 스택 영역등을 모듈로 처리할 수 있어 공유와 각 영역에 대한 메모리 접근 보호가 편리하다.

반면 단점으로는 가변 분할 방식의 단점인 "외부 단편화"가 발생한다.







