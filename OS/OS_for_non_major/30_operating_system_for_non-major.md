> 그림으로 쉽게 배우는 운영체제 - 감자님 강의 참조
우리는 프로세스가 실행될 때 프로세스를 이루고 있는 코드 영역, 데이터 영역, 힙 영역, 스택 영역과 같은 모듈이 모두 메모리에 올라와 실행된다고 알고 있다.

하지만 실제로는 모든 모듈이 메모리에 올라오는 것이 아니라 필요한 모듈만 올라와서 실행된다.
이게 어떻게 가능할까?

프로그램이 실행될 때 90%시간이 10%의 코드에서 보내는 것을 의미한다.

이것을 지역성 이론이라고 말하는데 지역성은 두 가지가 있다.

첫 번째는 공간의 지역성으로 현재 위치에서 가까운 데이터에 접근할 확률이 높다는 것이다.

두 번째는 시간의 지역성으로 현재 기준으로 가까운 시간에 접근했던 데이터가 먼 시간에 접근했던 데이터보다 접근할 확률이 높다는 것이다.

프로그램을 작성할 때 goto문은 되도록이면 사용하지 말라고 하는데 이는 코드의 구조파악이 어려운것도 있지만 지역성 이론에 따라 성능이 좋지 않기 때문에 그렇다.

지역성 이론은 조만간 쓰일 데이터만 메모리에 올리고 당분간 필요하지 않을 것 같은 데이터는 스왑영역으로 보내 성능을 향상 시킨다.

디맨드 페이징은 조만간 필요할 것 같은 데이터를 메모리로 가져오고 쓰이지 않을것 같은 데이터는 스왑영역으로 이동시키는 정책이다.

포토샵을 예로 들면 포토샵같은 프로그램은 본 프로그램 외에도 이미지에 효과를 주는 외부 필터들이 있다. 이 필터들을 포토샵과 같이 메모리에 모두 올리면 메모리를 많이 차지해서 프로그램이 더 무거워 진다.

그래서 본 프로그램만 메모리에 올리고 외부 필터들은 사용자의 요청이 있을때만 메모리로 가져오는 것이 메모리도 절약되고 메모리를 효율적으로 관리할 수 있고 프로그램의 응답속도도 빨라진다.

메모리 계층 구도

메모리는 레지스터, 캐시, 메인 메모리, 보조저장장치로 나눌 수 있다.

레지스터는 CPU내에 존재하고 CPU의 한 사이클에 접근할 수 있어서 굉장히 빠르다.

캐시는 CPU의 수 사이클에서 수십 사이클에 접근할 수 있고 

메인 메모리는 수 백사이클이 걸린다.

반면 보조저장장치에는 수백만 사이클이 걸려 굉장히 오래 걸린다.

현실 세계에서 상자를 가지러 간다고 생각할 때 레지스터는 같은 방에 있는 상자를 가지러가는 것과 같다.

보조저장장치 같은 경우는 상자를 가지러 달나라에 가는 경우와 같다.

이처럼 메모리에 접근하는 시간이 보조저장장치로 갈수록 느려진다.

디맨드 페이징은 스왑영역을 보조저장장치에 저장하는데 성능향상을 위해서는 스왑영역으로 데이터를 이동시키는 것을 최소화 시켜야 할 것이다.

가상 메모리의 크기는 물리 메모리 크기에 스왑영역을 합친 것이다.

스왑영역에서 물리 메모리로 데이터를 가져오는 것을 스왑인이라고 부른다.
물리메모리에서 스왑영역으로 데이터를 보내는 것을 스왑아웃이라고 부른다.

가상주소가 주어지면 메모리관리자는 페이지 테이블을 참조해서 물리 메모리가 있는 프레임을 알아내거나 스왑영역이 있는 위치를 알아내야하는데 이를 위해 페이지 테이블에는 여러가지 비트가 있다.

페이지 테이블을 이루고 있는 한 행을 페이지 테이블 엔트리라고 부른다.

이전 "페이징" 강의에서 페이지 테이블 엔트리는 프레임 넘버로 구성되어 있다고 했는데 실제로는 더 많은 비트들이 있다.

접근 비트는 페이지가 메모리에 올라온 후 데이터에 접근이 있었는지 알려주는 비트이다.
메모리에 읽기나 실행 작업을 했다면 1로 바뀌게 된다.

변경비트는 페이지가 메모리에 올라온 후 데이터의 변경이 있었는지 알려주는 비트다. 메모리에 쓰기작업을 했으면 1로 바뀌게 된다.

유효비트는 페이지가 물리 메모리에 있는지 알려주는 비트이다. 만약 유효비트가 1이라면 페이지가 스왑영역에 있고 0이라면 물리영역에 있다는 뜻이다.

읽기/쓰기/실행 비트는 권한 비트로 해당 메모리에 접근 권한이 있는지 검사하는 비트이다.

프로세스가 가상메모리에 접근 요청을 했을 때 메모리관리자는 페이지 테이블을 보고 물리 메모리의 프레임을 찾아내는데 만약 물리 메모리가 없다면 Page Fault라는 인터럽트를 발생시킨다.

Page Fault가 발생하면 보조저장장치의 스왑영역에 접근하게 되고 해당 프로세스는 대기상태가 된다.

그럼 스왑영역에 있는 데이터가 메모리로 올라가는 작업을 시작하고 메모리로 올라갔다면 대기상태에 있던 프로세스는 다시 실행하게 된다.

그럼 세 가지 상황에서 가상 메모리 주소가 어떻게 물리 메모리와 스왑영역에서 참조되는지 알아보겠다.

첫 번째 상황은 스왑이 필요없는 경우이다. 프로세스가 페이지 0을 요청했다고 가정해보자.

페이지 테이블의 0번 인덱스를 살펴보면 유효비트가 0이고 프레임 넘버가 1이다.
이 말은 해당 주소가 물리 메모리의 1번 프레임이라는 뜻이다.

그럼 물리 메모리에 있는 1번 프레임에 접근해 데이터를 참조한다.

두 번째 상황은 스왑영역에 있는 데이터를 참조하는 경우이다.

프로세스가 페이지 2번을 요청했다고 가정하자.
페이지 테이블의 2번 인덱스를 살펴보면 유효비트가 1이고 프레임 넘버가 2이다.
이 말은 페이지가 스왑영역2번에 있다는 뜻이다.

그럼 물리메모리의 적절한 빈 공간을 찾는다. 여기선 3번 프레임이라고 하겠다.

그럼 스왑영역 2번에 저장된 C를 물리 메모리 3번 프레임으로 가져오고 페이지 테이블에서 해당 엔티리의 유효비트를 0으로 프레임 넘버를 3으로 수정한다.

그리고 프레서스에게 데이터를 참조하게 해준다.

세 번째 상황은 물리메모리가 꽉찼을 때 스왑영역에 있는 데이터를 참조하는 경우이다.
프로세스가 페이지 1번을 요청했다고 가정해보겠다.

페이지 테이블 1번 인덱스를 살펴보면 유효비트가 1이고 프레임 넘버가 0이다.

이 말은 페이지가 스왑영역 0번에 있다는 뜻이다.

물리메모리로 가져오기 위해 적절히 빈곳을 찾지만 꽉차서 여유가 없다.

그럼 현재 물리 메모리에서 필요하지 않다고 판단하는 영역을 스왑영역으로 옮긴다.

여기선 A가 필요하지 않다고 생각하고 스왑영역 3번으로 옮긴다.

페이지 테이블에서 A가 저장된 0번 인덱스의 유효비트를 1로, 프레임 넘버를 3으로 변경한다.

이제 물리메모리에 공간이 생겼기 때문에 B를 물리메모리 1번으로 가져온다.

페이지 테이블에서 B가 젖아된 1번 인덱스의 유효비트를 0으로, 프레임 넘버를 1로 수정한다.

그리고 프로세스에게 데이터를 참조하게 해준다.

스왑영역에서 물리메모리로 가져오는 스왑인과 물리메모리에서 스왑영역으로로 보내는 스왑아웃을 할 때 어떤게 적절한지는 운영체제가 판단한다.

이 판단하는 것을 페이지 교체 알고리즘이라고 부른다.









