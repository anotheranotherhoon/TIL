> 그림으로 쉽게 배우는 운영체제 - 감자님 강의 참조
고정분할 방식을 이용한 페이징을 알아보자

세그멘테이션 기법은 외부단편화 문제가 있기 때문에 일르 해결하기 위해 고안되었다.

페이징은 메모리를 할당 할 때 정해진 크기의 페이지로 나누다.

모든 페이지는 크기가 같기 때문에 관리가 굉장히 쉽다.

또한 일정한 크기로 나눴기 때문에 외부단편화 현상이 일어나지 않는다. 대신에 내부단편화가 일어난다.

여기에 "논리주소공간"과 "물리주소공간"이 있다.

논리주소공간은 사용자와 프로세스가 바라보는 주소공간이고 

물리주소공간은 실제 메모리에서 사용되는 주소공간이다.

페이징에서 논리주소공간은 일정한 크기로 균일하게 나뉜다.

이것을 "페이지"라고 부른다.

물리주소공간도 페이지의 크기와 동일하게 나뉘는데 이걸 "프레임"이라고 부른다.

페이징의 주소변환 방법

세그멘테이션과 마찬가지로 메모리관리자는 테이블을 가지고 있는데 이를 페이지 테이블이라고 부른다.

CPU에서 논리주소를 전달해주면 메모리관리자는 이 논리주소가 몇번 페이지인지, 오프셋은 얼마인지 알아낸다.

그리고 메모리 관리자내에 Page Table Base Register(PTBR)를 이용해서 물리 메모리에 있는 페이지 테이블을 찾고 페이지 번호를 인덱스로 프레인 번호를 알아내고 오프셋을 이요해 물리주소로 변환을 한다.

오프셋은 계산을 통해 쉽게 구할 수 있다.

페이지 테이블에 Invalid로 표시되어있으면 스왑영역, 즉 하드디스크에 저장되어있다는 의미이다.

세그멘테이션과 마찬가지로 Page Table Base Register는 운영체제가 컨텍스트 스위칭을 할 때 마다 해당 프로세스의 것으로 업데이트 해준다.

32bit CPU의 주소변환
32bit CPU에서 가상 메모리의 크기는 2<sup>32</sup>로 바이트 대략 4GB이다.
이 4GB의 가상메모리를 크기가 16MB인 페이지로 나눈다.

그럼 32bit 중에 24bit는 페이지 크기를 나타내고 나머지 8bit는 페이지 번호를 나타낸다.

페이지 번호는 2<sup>8</sup>이니까 총 256개의 페이지가 있다.

이렇게 나눴으면 4GB메모리가 16MB의 페이지 256개로 나뉜다.

페이지 0은 0~16777216번지 페이지 1은 16777217 ~ 33554432번지로, 
페이지 255는 4278190081 ~ 4294967296번지로 구성된다.

이제 물리주소의 프레임도 가상주소의 페이지의 크기와 동일한 16MB로 나눠준다.

물리주소는 프레임이 128개로 2GB정도 밖에 안되게 가정하자.

이는 물리주소의 크기가 가상주소의 크기보다 작아도 문제가 없음을 보여주기 위해서이다.

부족한 물리주소는 스왑처리를 하기 때문에 괜찮다.

메모리 관리자 내의 페이지 테이블은 1차원 배열로 구성되어 있는데 페이지 번호가 배열의 인덱스가 된다.

해당 인덱스로 가면 프레임을 얻을 수 있다.

이제 여기서 CPU가 논리 주소 0x1000번째에 접근한다고 가정해보자.
논리주소 0x1000의 물리주소를 구해보자.

페이지 넘버를 구하는 공식은 논리주소를 페이지 크기로 나눈 몫이다.

0x1000의 페이지 넘버는 0이다.

세그멘테이션과 페이징은 굉장히 비슷해보인다.

이 둘의 차이점은 뭘까?

바로 페이지의 크기이다.

세그멘테이션은 프로세스마다 크기가 달라 Bound Address를 가지고 있지만

페이징은 모든 페이지의 크기가 동일해서 Bound Address가지지 않는다.

페이징은 이러한 특징 때문에 외부단편화는 발생하지 않지만 내부단편화가 발생한다.

정해진 크기의 페이징보다 프로세스의 정보가 작으면 그만큼 공간이 낭비되는데 이를 내부 단편화라고 부른다.

하지만 세그멘테이션의 단점과 비교하면 많은 공간이 낭비되는게 아니라서 심각하게 생각하지는 않는다. 

또 다른 차이점은 뭘까?

세그멘테이션은 논리적인 영역별로 세그먼트를 나눈다. 세그먼트마다 크기를 다르게 나눌 수 있으니 코드, 힙, 데이터, 스택영역등으로 나눌 수 있다.

하지만 페이징은 페이지의 크기가 고정되어 있어 논리적인 영역별로 나누는 것이 아니라 페이지로 나누기 때문에 논리적인 영역을 나눌 수 없다. 그래서 특정영역만 딱 떼어내서 공유하거나 권한을 부여하는게 더 어렵다.

페이징에서 가장 신경써야하는 것은 페이지 테이블의 크기이다.

각 프로세스마다 페이지 테이블을 가지고 있는데 프로세스가 많아질수록 페이지 테이블도 많아지기 때문에 프로세스마다 실제로 사용할 수 있는 메모리영역이 줄어든다.

실제로 메모리 관리자가 참조하는 페이지 테이블도 물리 메모리의 운영체제 영역에 저장되어 있기 때문에 페이지 테이블 크기가 너무 크면 사용자 영역이 부족하게 된다.

이 때문에 페이지 테이블의 크기를 적절하게 유지하는 것이 굉장히 중요하다.




