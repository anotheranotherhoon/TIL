> 그림으로 쉽게 배우는 운영체제 - 감자님 강의 참조
메인 메모리를 알아보자.

폰노이만 구조의 컴퓨터는 모든 프로그램을 메모리에 올려 실행시킨다.

유니프로그래밍 환경에서는 하나의 프로그램만 메모리에 올라오기 때문에 메모리관리가 어렵지 않았으나 
멀티 프로그래밍 환경에선 여러 프로세스가 올라오니 복잡하고 어려워졌다.

운영체제는 메모리를 관리하기 위해서 1바이트 크기로 구역을 나누고 숫자를 매긴다 .이 숫자를 주소라고 부른다.

32bit CPU는 레지스터 크기가 32bit이고 CPU가 처리하는 ALU(산술논리연산장치)도, 데이터가 이동하는 버스도 32bit이다. 또한 CPU가 다룰 수 잇는 메모리도 2<sup>32</sup>로 4GB이다.

64bit CPU는 레지스터 크기와 ALU, 버스의 크기도 64bit이다. 다룰 수 있는 메모리 크기는 2<sup>64</sup>으로 거의 무한대에 가깝다. 

64bit CPU가 32 bit CPU보다 한번에 처리할 수 있는 양이 많기 때문에 속도가 더 빠르다.

메모리를 컴퓨터에 연결하면 0x0x번지 부터 시작하는 주소공간이 있는데 이를 "물리 주소 공간"이라고 합니다.

이와 다르게 사용자 관점에서 바라본 주소공간은 "논리 주소 공간"이라고 부릅니다.

사용자는 물리주소를 몰라도 논리 주소로 물리 주소에 접근할 수 있다.

메모리에는 운영체제와 수 많은 프로세스가 올라온다.

그 중에 운영체제는 특별하기 때문에 운영체제를 위한 공간은 따로 마련해둔다.

만약에 사용자가 악의적인 프로그램을 만들어 사용자 프로세스가 운영체제를 침범하면 굉장히 위험할 수도 있습니다.

그래서 하드웨어적으로 운영체제 공간과 사용자 공간을 나누는 경계레지스터를 만들었다.

경계 레지스터는 CPU내에 존재하는 레지스터로 메모리 관리자가 사용자 프로세스가 경계 레지스터의 값을 벗어났는지 검사하고 만약 벗어났다면 그 프로세스를 종료시킨다.

메모리에는 절대 주소와 상대 주소라는 개념이 있다.
개발자는 프로그램을 만들 때 프로그램이 실행될 주소를 신경쓰지 않고 개발을 한다.

이는 컴파일러가 컴파일을 할 때 메모리 0번지에서 실행한다고 "가정"하기 때문이다.

개발자의 프로그램을 실행시켜 메모리의 사용자 공간 4000번지에 올라왔다고 가정해보자.

컴파일러는 0x0번지라고 가정해서 프로그램을 만들었고 이는 "상대 주소"이다.

실제 프로그램이 올라간 주소는 0x4000번지인데 이는 메모리 관리자가 바라본 "절대주소"이다.

사용자가 바라본 주소인 "상대 주소"는 논리 주소라고 부르고 메모리 관리자가 바라본 주소인 "절대 주소"는 "물리 주소 공간"이라고 부른다.

사용자가 0x100번지 (상대 주소, 논리 주소)에 있는 데이터를 요청한다. 
CPU는 메모리 관리자에게 0x100번지에 있는 데이터를 가져오라고 한다.
메모리 관리자는 CPU가 요청한 0x100번지와 재배치 레지스터에 있는 0x4000번지 값을 더한 0x4100번지(절대 주소, 물리 주소)에 접근해서 데이터를 가져온다. 재배치 레지스터에는 프로그램의 시작 주소가 저장되어 있다. 메모리 관리자는 사용자가 메모리에 접근할 때 마다 이렇게 계산한다. 

메모리 관리자 덕분에 모든 사용자 프로세스는 0x0번지 부터 시작한다는 가정으로 편하게 프로그램을 만들 수 있고 만약 시작영역이 바뀌더라도 재배치 레지스터만 변경해주면 되기 때문에 굉장히 유연하다.