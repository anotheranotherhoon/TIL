> 그림으로 쉽게 배우는 운영체제 - 감자님 강의 참조

MLFQ는 RR의 업그레이드된 알고리즘이기 때문에 RR알고리즘의 예로 알아보겠다.

프로세스 두 개가 있다. 
첫 번째 프로세스는 P1 이고 두 번째 프로세스는 P2이다.
P1은 I/O작업 없이 CPU연산만 하는 프로세스이다.
P2는 1초 CPU연산을 하고 10초 동안 I/O 작업을 한다.

여기서 P1은 대부분의 시간을 CPU연산을 하기 때문에 "CPU Bound Process"라고 한다.
반면 P2는 대부분의 시간을 I/O 작업으로 보내고 CPU연산은 조금하기 때문에 I/O Bound Process"라고 한다. 

CPU Bound Process가 가장 중요하게 생각하는 건 CPU 사용률과 처리량이다.
I/O Bound Process가 가장 중요하게 생각하는 건 응답속도이다.
키보드나 마우스 사용을 했는데 반응이 느리면 사용자가 많이 답답해할 것 이다.

이제 이 프로세스를 가지고 두 개의 상황에서 실행시켜 보겠다.

첫 번째 상황은 타임슬라이스가 100초인 경우이다.
P2가 먼저 실행된다고 가정해 보자.
P2는 1초 실행되고 I/O작업을 요청하고 기다린다.
이제 P1이 실행되는데 타임 슬라이스 크기인 100초 만큼 실행된다.
P1이 실행되는 도중에 10초가 지났을 때 P2가 요청한 I/O작업이 완료되고 인터럽트가 발생한다.
그럼 P2는 다시 큐에 들어가 CPU를 할당 받을 준비가 된다.
P1은 100초 실행되면 CPU를 뺏기게 되고 큐에 있던 P2는 다시 1초 실행되고 I/O작업을 요청하고 다시 기다린다. 이 과정이 모든 작업이 완료될 때 까지 계속 반복된다.

두 번째 상황은 타임슬라이스가 1초인 경우이다.
P2가 1초 실행되고 I/O작업을 요청하고 기다린다.
이제 P1이 실행되는데 타임 슬라이스 크기인 1초 만큼 실행된다.
지금 P2는 I/O작업이 끝나지 않아서 계속 기다리는 상황이다.
그렇기 때문에 P1은 종료되고 바로 큐에 들어가는데 큐가 비어있기 때문에 P1이 다시 바로 실행된다.
이렇게 P1이 10번 , 즉 10초 동안 실행되면 P2의 I/O 작업이 끝나 인터럽트가 발생되고 P2는 큐에 들어간다. 그럼 P2는 1초 실행되고 다시 I/O 작업을 기다린다. 지금 설명한대로 모든 작업이 완료될때 까지 계속 반복 된다.

이제 이 두 가지 상황을 비교해 보자. 
첫 번째 상황의 경우 CPU사용률을 보면 CPU는 쉬지 않고 일하기 때문에 CPU사용률이 100%이다. 하지만 I/O 사용률을 보면 P1이 실행되는 동안P2의 I/O 작업이 완료된 시점부터 기다리는 시간이 발생하기 때문에 I/0 사용률은 101분의 10으로 10%정도 밖에 되지 않는다.

두 번째 상황도 CPU 사용률을 보면 CPU는 쉬지 않고 일하기 때문에 사용률을 100%이다.
I/O사용률은 첫번째 상황과 다르다. P1의 타임 슬라이스가 작기 때문에 P2가 첫 번째 상황처럼 기다리며 낭비되는 시간이 거의 없고 11분의 10으로 대략 90%정도가 나온다.

CPU와 I/O 사용률을 고려해보면 타임 슬라이스가 작은 값이 더 좋다는 결론이 나온다.

운영체제를 연구하는 사람들은 손해보는 프로세스가 어떻게 하면 손해보지 않을까 고민하게 된다. 여기서 MLFQ가 탄생한다.

MLFQ는 기본적으로는 CPU 사용률과 I/O 사용률이 좋게 나오는 작은 크기의 타임 슬라이스를 선택한다. 그리고 P1과 같은 CPU Bounce Process들에게는 타임슬라이스를 크게 준다.

그럼 운영체제 입장에서 CPU Bound Process 와 I/O Bound Process를 어떻게 구별할까?

CPU를 사용하는 프로세스가 실행하다가 스스로 CPU를 반납하면 CPU사용이 적은거니 I/O Bound Process일 확률이 높다.

반대로 CPU를 사용하는 프로세스가 타임 슬라이스 크기를 오버해서 CPU스케줄러에 의해 강제로 CPU를 뻇기는 상황이면 CPU 사용이 많은 것이니 CPU Bound Process일 확률이 높다. 

이러한 아이디어를 통해서 우선순위를 가진 큐를 여러 개 준비한다.
우선 순위가 높으면 타임 슬라이스가 작고 우선 순위가 낮을 수록 타임 슬라이스 크기가 커진다.

만약 P1처럼 타임 슬라이스 크기를 오버해서 강제로 CPU를 뺏긴다면 P1은 원래 있던 큐보다 우선 순위가 더 낮은 큐로 이동하게 된다. 그러면 다음번에 실행될 때는 타임 슬라이스 크기가 조금 더 커지게 되고 여기서도 부족하면 다음에는 더 큰 타임 슬라이스를 할당 받게 된다.
최종적으로는 타임슬라이스가 무한초에 가깝게 할당 되기 때문에 FIFO처럼 연속적으로 작업을 마칠 수 있게 된다. 
이 외에도 많은 알고리즘이 있지만 오늘 날 쓰이는 CPU스케줄링 알고리즘은 MLFQ가 주류 이다.

